// Generated by CoffeeScript 1.3.3
var Joint;

Joint = (function() {

  Joint.prototype.body = null;

  Joint.prototype.motor = null;

  Joint.prototype.children = {};

  function Joint(id, name, axis, position, bodyIsChild, parallelJoints, opposingJoints) {
    this.id = id;
    this.name = name;
    this.axis = axis;
    this.bodyIsChild = bodyIsChild;
    this.parallelJoints = parallelJoints != null ? parallelJoints : [];
    this.opposingJoints = opposingJoints != null ? opposingJoints : [];
    this.sceneNode = new THREE.Object3D();
    this.sceneNode.position.set(position.x, position.y, position.z);
    this.axis.normalize();
    scene.add(this.sceneNode);
    scene.updateMatrixWorld();
  }

  Joint.prototype.rotate = function(radians) {
    var joint, matrix, _i, _j, _len, _len1, _ref, _ref1, _results;
    matrix = new THREE.Matrix4().makeRotationAxis(this.axis, radians);
    this.sceneNode.matrix.multiplySelf(matrix);
    this.sceneNode.rotation.getRotationFromMatrix(matrix, this.sceneNode.scale);
    _ref = this.parallelJoints;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      joint = _ref[_i];
      joint.rotate(radians);
    }
    _ref1 = this.opposingJoints;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      joint = _ref1[_j];
      _results.push(joint.rotate(-radians));
    }
    return _results;
  };

  Joint.prototype.addBodyChild = function(bodyMesh) {
    var bodyMatrixWorld, invSceneNodeMatrixWorld;
    bodyMatrixWorld = new THREE.Matrix4();
    bodyMatrixWorld.copy(bodyMesh.matrixWorld);
    if (bodyMesh.parent != null) {
      bodyMesh.parent.remove(bodyMesh);
    }
    invSceneNodeMatrixWorld = new THREE.Matrix4();
    invSceneNodeMatrixWorld.getInverse(this.sceneNode.matrixWorld);
    bodyMesh.matrix.multiply(invSceneNodeMatrixWorld, bodyMatrixWorld);
    bodyMesh.rotation.getRotationFromMatrix(bodyMesh.matrix, bodyMesh.scale);
    bodyMesh.position.getPositionFromMatrix(bodyMesh.matrix);
    this.sceneNode.add(bodyMesh);
    return scene.updateMatrixWorld();
  };

  Joint.prototype.addJointChild = function(joint) {
    var childMatrixWorld, invSceneNodeMatrixWorld;
    childMatrixWorld = new THREE.Matrix4();
    childMatrixWorld.copy(joint.sceneNode.matrixWorld);
    this.children[joint.id] = joint;
    if (joint.sceneNode.parent != null) {
      joint.sceneNode.parent.remove(joint.sceneNode);
    }
    invSceneNodeMatrixWorld = new THREE.Matrix4();
    invSceneNodeMatrixWorld.getInverse(this.sceneNode.matrixWorld);
    joint.sceneNode.matrix.multiply(invSceneNodeMatrixWorld, childMatrixWorld);
    joint.sceneNode.rotation.getRotationFromMatrix(joint.sceneNode.matrix, joint.sceneNode.scale);
    joint.sceneNode.position.getPositionFromMatrix(joint.sceneNode.matrix);
    this.sceneNode.add(joint.sceneNode);
    if (joint.hasBody() && !joint.bodyIsChild) {
      return this.addBodyChild(joint.body);
    } else {
      return scene.updateMatrixWorld();
    }
  };

  Joint.prototype.setBody = function(bodyMesh) {
    this.body = bodyMesh;
    if (this.bodyIsChild) {
      return this.addBodyChild(bodyMesh);
    }
  };

  Joint.prototype.hasBody = function() {
    return this.body != null;
  };

  Joint.prototype.hasMotor = function() {
    return this.motor != null;
  };

  Joint.prototype.hasParent = function() {
    return this.sceneNode.parent != null;
  };

  return Joint;

})();
